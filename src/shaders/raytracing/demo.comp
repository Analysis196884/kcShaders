#version 430 core

layout(local_size_x = 16, local_size_y = 16) in;
layout(rgba32f, binding = 0) uniform image2D outputImage;

// Uniforms
uniform vec3 iResolution;
uniform float iTime;
uniform int iFrame;
uniform int maxBounces;
uniform int samplesPerPixel;

// Camera uniforms
uniform vec3 cameraPosition;
uniform vec3 cameraFront;
uniform vec3 cameraUp;
uniform vec3 cameraRight;
uniform float cameraFov;

// Random number generator (simple hash-based)
uint seed;

uint hash(uint x) {
    x ^= x >> 16;
    x *= 0x7feb352dU;
    x ^= x >> 15;
    x *= 0x846ca68bU;
    x ^= x >> 16;
    return x;
}

float random() {
    seed = hash(seed);
    return float(seed) / 4294967296.0;
}

vec3 randomInUnitSphere() {
    // Use rejection sampling with a maximum iteration limit to avoid infinite loops
    vec3 p;
    for (int i = 0; i < 8; i++) {  // Max 8 iterations
        p = 2.0 * vec3(random(), random(), random()) - 1.0;
        if (dot(p, p) < 1.0) {
            return p;
        }
    }
    // Fallback: return normalized random vector
    return normalize(p);
}

// Ray structure
struct Ray {
    vec3 origin;
    vec3 direction;
};

// Hit record
struct HitRecord {
    bool hit;
    float t;
    vec3 point;
    vec3 normal;
    vec3 albedo;
};

// Sphere intersection
HitRecord intersectSphere(Ray ray, vec3 center, float radius, vec3 albedo) {
    HitRecord rec;
    rec.hit = false;
    
    vec3 oc = ray.origin - center;
    float a = dot(ray.direction, ray.direction);
    float b = 2.0 * dot(oc, ray.direction);
    float c = dot(oc, oc) - radius * radius;
    float discriminant = b * b - 4.0 * a * c;
    
    if (discriminant > 0.0) {
        float t = (-b - sqrt(discriminant)) / (2.0 * a);
        if (t > 0.001) {
            rec.hit = true;
            rec.t = t;
            rec.point = ray.origin + t * ray.direction;
            rec.normal = normalize(rec.point - center);
            rec.albedo = albedo;
        }
    }
    
    return rec;
}

// Scene intersection (simple demo scene)
HitRecord intersectScene(Ray ray) {
    HitRecord closest;
    closest.hit = false;
    closest.t = 1e10;
    
    // Ground plane (large sphere)
    HitRecord ground = intersectSphere(ray, vec3(0.0, 0.0, -1000), 1000.0, vec3(0.5, 0.5, 0.5));
    if (ground.hit && ground.t < closest.t) {
        closest = ground;
    }
    
    // Center sphere
    HitRecord sphere1 = intersectSphere(ray, vec3(-1.45, 0.0, 0.8), 0.8, vec3(0.8, 0.3, 0.3));
    if (sphere1.hit && sphere1.t < closest.t) {
        closest = sphere1;
    }
    
    // Left sphere
    HitRecord sphere2 = intersectSphere(ray, vec3(0.0, 0.0, 0.6), 0.6, vec3(0.3, 0.8, 0.3));
    if (sphere2.hit && sphere2.t < closest.t) {
        closest = sphere2;
    }
    
    // Right sphere
    HitRecord sphere3 = intersectSphere(ray, vec3(1.0, 0.0, 0.4), 0.4, vec3(0.3, 0.3, 0.8));
    if (sphere3.hit && sphere3.t < closest.t) {
        closest = sphere3;
    }
    
    return closest;
}

// Simple sky color
vec3 skyColor(vec3 direction) {
    float t = 0.5 * (direction.y + 1.0);
    return mix(vec3(1.0, 1.0, 1.0), vec3(0.5, 0.7, 1.0), t) * 1.5; // Brighter sky
}

// Ray trace a single ray
vec3 trace(Ray ray) {
    vec3 color = vec3(1.0);
    
    for (int bounce = 0; bounce < maxBounces; bounce++) {
        HitRecord hit = intersectScene(ray);
        
        if (hit.hit) {
            // Lambertian diffuse
            vec3 randomDir = randomInUnitSphere();
            vec3 target = hit.point + hit.normal + randomDir;
            vec3 newDir = target - hit.point;
            
            // Ensure direction is valid
            float dirLength = length(newDir);
            if (dirLength < 0.001) {
                // Degenerate direction, use normal instead
                newDir = hit.normal;
            } else {
                newDir = normalize(newDir);
            }
            
            ray.origin = hit.point + hit.normal * 0.001; // Offset to avoid self-intersection
            ray.direction = newDir;
            color *= hit.albedo;
            
            // Prevent color from becoming too dark or invalid
            if (dot(color, color) < 0.001) {
                return vec3(0.0);
            }
        } else {
            // Hit sky
            color *= skyColor(ray.direction);
            break;
        }
    }
    
    return color;
}

void main() {
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    
    // Check bounds
    if (pixelCoords.x >= int(iResolution.x) || pixelCoords.y >= int(iResolution.y)) {
        return;
    }
    
    // Initialize random seed
    seed = hash(uint(pixelCoords.x) + uint(pixelCoords.y) * uint(iResolution.x) + uint(iFrame) * 719393u);
    
    // Generate ray from camera
    // Convert pixel coordinates to NDC space [-1, 1]
    vec2 uv = (vec2(pixelCoords) + vec2(random(), random())) / iResolution.xy;
    uv = uv * 2.0 - 1.0;  // Map from [0,1] to [-1,1]
    
    // Calculate aspect ratio
    float aspect = iResolution.x / iResolution.y;
    
    // Calculate FOV scale
    float fovRadians = radians(cameraFov);
    float halfHeight = tan(fovRadians * 0.5);
    float halfWidth = aspect * halfHeight;
    
    // Calculate ray direction in camera space
    vec3 rayDir = normalize(
        cameraFront + 
        uv.x * halfWidth * cameraRight + 
        uv.y * halfHeight * cameraUp
    );
    
    Ray ray;
    ray.origin = cameraPosition;
    ray.direction = rayDir;
    
    // Trace rays (multi-sampling)
    vec3 color = vec3(0.0);
    for (int i = 0; i < samplesPerPixel; i++) {
        color += trace(ray);
    }
    color /= float(samplesPerPixel);
    
    // Clamp to prevent invalid values
    color = clamp(color, 0.0, 10.0);
    
    // Gamma correction
    color = pow(color, vec3(1.0 / 2.2));
    
    // Final clamp
    color = clamp(color, 0.0, 1.0);
    
    // Write to output texture
    imageStore(outputImage, pixelCoords, vec4(color, 1.0));
}
