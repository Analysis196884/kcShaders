#version 430 core

layout(local_size_x = 16, local_size_y = 16) in;
layout(rgba32f, binding = 0) uniform image2D outputImage;
layout(rgba32f, binding = 1) uniform image2D accumulationImage;  // Temporal accumulation

// Uniforms
uniform vec3 iResolution;
uniform float iTime;
uniform int iFrame;
uniform int maxBounces;
uniform int samplesPerPixel;

// Camera uniforms
uniform vec3 cameraPosition;
uniform vec3 cameraFront;
uniform vec3 cameraUp;
uniform vec3 cameraRight;
uniform float cameraFov;

// Scene data structures (std430 layout)
struct GpuVertex {
    vec3 position;
    float _pad0;
    vec3 normal;
    float _pad1;
    vec2 uv;
    vec2 _pad2;
};

struct GpuTriangle {
    uint v0, v1, v2;
    uint materialId;
};

struct BVHNode {
    vec3 boundsMin;
    uint leftFirst;
    vec3 boundsMax;
    uint triCount;
};

struct GpuMaterial {
    vec3 albedo;
    float metallic;
    vec3 emissive;
    float roughness;
    float ao;
    float opacity;
    float emissiveStrength;
    float _pad0;
};

// SSBOs
layout(std430, binding = 1) buffer Vertices {
    GpuVertex vertices[];
};

layout(std430, binding = 2) buffer Triangles {
    GpuTriangle triangles[];
};

layout(std430, binding = 3) buffer BVHNodes {
    BVHNode nodes[];
};

layout(std430, binding = 4) buffer Materials {
    GpuMaterial materials[];
};

// Random number generator
uint seed;

uint hash(uint x) {
    x ^= x >> 16;
    x *= 0x7feb352dU;
    x ^= x >> 15;
    x *= 0x846ca68bU;
    x ^= x >> 16;
    return x;
}

float random() {
    seed = hash(seed);
    return float(seed) / 4294967296.0;
}

vec3 randomInUnitSphere() {
    vec3 p;
    do {
        p = 2.0 * vec3(random(), random(), random()) - vec3(1.0);
    } while (length(p) >= 1.0);
    return p;
}

vec3 sampleHemisphereCosine(vec3 N) {
    float r1 = random();
    float r2 = random();

    float PI = 3.14159;
    float phi = 2.0 * PI * r1;
    float r = sqrt(r2);

    vec3 local = vec3(
        r * cos(phi),
        r * sin(phi),
        sqrt(1.0 - r2)
    );

    // transform to world space (TBN)
    vec3 T = normalize(cross(abs(N.y) < 0.99 ? vec3(0,1,0) : vec3(1,0,0), N));
    vec3 B = cross(N, T);

    return normalize(local.x * T + local.y * B + local.z * N);
}

// Ray structure
struct Ray {
    vec3 origin;
    vec3 direction;
};

// Hit record
struct HitRecord {
    bool hit;
    float t;
    vec3 point;
    vec3 normal;
    uint materialId;
};

// AABB intersection
bool intersectAABB(Ray ray, vec3 boundsMin, vec3 boundsMax) {
    vec3 invDir = 1.0 / ray.direction;
    vec3 t0 = (boundsMin - ray.origin) * invDir;
    vec3 t1 = (boundsMax - ray.origin) * invDir;
    vec3 tmin = min(t0, t1);
    vec3 tmax = max(t0, t1);
    float tenter = max(max(tmin.x, tmin.y), tmin.z);
    float texit = min(min(tmax.x, tmax.y), tmax.z);
    return tenter <= texit && texit > 0.001;
}

// Helper: Interpolate and fix normal orientation
vec3 interpolateNormal(vec3 n0, vec3 n1, vec3 n2, float u, float v, vec3 rayDir) {
    float w = 1.0 - u - v;
    vec3 normal = w * n0 + u * n1 + v * n2;
    
    // Normalize (important for interpolated normals)
    float len = length(normal);
    if (len > 0.001) {
        normal = normal / len;
    } else {
        // Fallback to geometric normal if interpolation failed
        return normalize(cross(n1 - n0, n2 - n0));
    }
    
    // Ensure normal faces the ray (flip if back-facing)
    if (dot(normal, rayDir) > 0.0) {
        normal = -normal;
    }
    
    return normal;
}

// Ray-Triangle intersection (Möller–Trumbore)
// Returns barycentric coordinates for normal interpolation
bool intersectTriangle(Ray ray, vec3 v0, vec3 v1, vec3 v2, out float t, out float u, out float v) {
    vec3 e1 = v1 - v0;
    vec3 e2 = v2 - v0;
    vec3 p = cross(ray.direction, e2);
    float det = dot(e1, p);
    
    if (abs(det) < 1e-6) return false;
    
    float invDet = 1.0 / det;
    vec3 s = ray.origin - v0;
    u = dot(s, p) * invDet;
    if (u < 0.0 || u > 1.0) return false;
    
    vec3 q = cross(s, e1);
    v = dot(ray.direction, q) * invDet;
    if (v < 0.0 || u + v > 1.0) return false;
    
    t = dot(e2, q) * invDet;
    if (t < 0.001) return false;
    
    return true;
}

// BVH traversal
HitRecord intersectBVH(Ray ray) {
    HitRecord closest;
    closest.hit = false;
    closest.t = 1e30;
    
    // Stack for traversal (no recursion on GPU)
    int stack[64];
    int stackPtr = 0;
    stack[stackPtr++] = 0;  // Start with root
    
    while (stackPtr > 0) {
        int nodeIdx = stack[--stackPtr];
        BVHNode node = nodes[nodeIdx];
        
        // Test AABB
        if (!intersectAABB(ray, node.boundsMin, node.boundsMax)) {
            continue;
        }
        
        if (node.triCount > 0) {
            // Leaf node - test triangles
            for (uint i = 0; i < node.triCount; i++) {
                GpuTriangle tri = triangles[node.leftFirst + i];
                
                // Get vertex positions
                vec3 v0 = vertices[tri.v0].position;
                vec3 v1 = vertices[tri.v1].position;
                vec3 v2 = vertices[tri.v2].position;
                
                // Test intersection and get barycentric coordinates
                float t, u, v;
                if (intersectTriangle(ray, v0, v1, v2, t, u, v) && t < closest.t) {
                    // Get vertex normals
                    vec3 n0 = vertices[tri.v0].normal;
                    vec3 n1 = vertices[tri.v1].normal;
                    vec3 n2 = vertices[tri.v2].normal;
                    
                    // Interpolate normal using barycentric coordinates and ensure proper orientation
                    vec3 interpolatedNormal = interpolateNormal(n0, n1, n2, u, v, ray.direction);
                    
                    closest.hit = true;
                    closest.t = t;
                    closest.point = ray.origin + t * ray.direction;
                    closest.normal = interpolatedNormal;
                    closest.materialId = tri.materialId;
                }
            }
        } else {
            // Internal node - push children
            if (stackPtr < 62) {  // Leave room for 2 children
                stack[stackPtr++] = int(node.leftFirst);
                stack[stackPtr++] = int(node.leftFirst) + 1;
            }
        }
    }
    
    return closest;
}

// Sky color
vec3 skyColor(vec3 direction) {
    float t = 0.5 * (2*direction.z + 2.0);
    return (1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0);
}

// Path tracing with materials
vec3 trace(Ray ray) {
    vec3 color = vec3(1.0);
    vec3 emitted = vec3(0.0);
    
    for (int bounce = 0; bounce < maxBounces; bounce++) {
        HitRecord hit = intersectBVH(ray);
        
        if (hit.hit) {
            // Get material
            GpuMaterial mat = materials[hit.materialId];
            
            // Add emissive contribution
            if (mat.emissiveStrength > 0.0) {
                emitted += color * mat.emissive * mat.emissiveStrength;
            }
            
            // Calculate next ray direction based on material
            vec3 scatter;
            if (mat.metallic > 0.5) {
                // Metallic - reflection
                vec3 reflected = reflect(normalize(ray.direction), hit.normal);
                scatter = normalize(reflected + mat.roughness * randomInUnitSphere());
            } else {
                // Dielectric - diffuse (Lambertian)
                scatter = sampleHemisphereCosine(hit.normal);
            }
            
            // Ensure valid direction
            if (dot(scatter, hit.normal) <= 0.0) {
                scatter = hit.normal;
            }
            
            // Update ray
            ray.origin = hit.point + hit.normal * 0.001;
            ray.direction = scatter;
            
            // Accumulate color with albedo
            color *= mat.albedo * mat.ao;
            
            // Russian roulette for path termination
            float p = max(color.r, max(color.g, color.b));
            if (random() > p) {
                break;
            }
            color /= p;
            
        } else {
            // Hit sky
            emitted += color * skyColor(ray.direction);
            break;
        }
    }
    
    return emitted;
}

void main() {
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    
    // Check bounds
    if (pixelCoords.x >= int(iResolution.x) || pixelCoords.y >= int(iResolution.y)) {
        return;
    }
    
    // Initialize random seed
    seed = hash(uint(pixelCoords.x) + uint(pixelCoords.y) * uint(iResolution.x) + uint(iFrame) * 719393u);
    
    // Generate ray from camera
    vec2 uv = (vec2(pixelCoords) + vec2(random(), random())) / iResolution.xy;
    uv = uv * 2.0 - 1.0;
    
    float aspect = iResolution.x / iResolution.y;
    float fovRadians = radians(cameraFov);
    float halfHeight = tan(fovRadians * 0.5);
    float halfWidth = aspect * halfHeight;
    
    vec3 rayDir = normalize(
        cameraFront + 
        uv.x * halfWidth * cameraRight + 
        uv.y * halfHeight * cameraUp
    );
    
    Ray ray;
    ray.origin = cameraPosition;
    ray.direction = rayDir;
    
    // Trace rays
    vec3 color = vec3(0.0);
    for (int i = 0; i < samplesPerPixel; i++) {
        color += trace(ray);
    }
    color /= float(samplesPerPixel);
    
    // Temporal accumulation
    vec4 prevAccum = imageLoad(accumulationImage, pixelCoords);
    
    // Mix with previous accumulation
    // frameCount starts at 0 when camera moves, so we add 1
    float weight = 1.0 / float(iFrame + 1);
    vec3 accumColor = mix(prevAccum.rgb, color, weight);
    
    // Store accumulated result
    imageStore(accumulationImage, pixelCoords, vec4(accumColor, 1.0));
    
    // Apply gamma correction for display
    vec3 displayColor = pow(accumColor, vec3(1.0 / 2.2));
    displayColor = clamp(displayColor, 0.0, 1.0);
    
    // Write to output texture
    imageStore(outputImage, pixelCoords, vec4(displayColor, 1.0));
}
