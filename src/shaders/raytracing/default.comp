#version 430 core

layout(local_size_x = 16, local_size_y = 16) in;
layout(rgba32f, binding = 0) uniform image2D outputImage;

// Uniforms
uniform vec3 iResolution;
uniform float iTime;
uniform int iFrame;
uniform int maxBounces;
uniform int samplesPerPixel;

// Camera uniforms
uniform vec3 cameraPosition;
uniform vec3 cameraFront;
uniform vec3 cameraUp;
uniform vec3 cameraRight;
uniform float cameraFov;

// Scene data structures (std430 layout)
struct GpuVertex {
    vec3 position;
    float _pad0;
    vec3 normal;
    float _pad1;
    vec2 uv;
    vec2 _pad2;
};

struct GpuTriangle {
    uint v0, v1, v2;
    uint materialId;
};

struct BVHNode {
    vec3 boundsMin;
    uint leftFirst;
    vec3 boundsMax;
    uint triCount;
};

struct GpuMaterial {
    vec3 albedo;
    float metallic;
    vec3 emissive;
    float roughness;
    float ao;
    float opacity;
    float emissiveStrength;
    float _pad0;
};

// SSBOs
layout(std430, binding = 1) buffer Vertices {
    GpuVertex vertices[];
};

layout(std430, binding = 2) buffer Triangles {
    GpuTriangle triangles[];
};

layout(std430, binding = 3) buffer BVHNodes {
    BVHNode nodes[];
};

layout(std430, binding = 4) buffer Materials {
    GpuMaterial materials[];
};

// Random number generator
uint seed;

uint hash(uint x) {
    x ^= x >> 16;
    x *= 0x7feb352dU;
    x ^= x >> 15;
    x *= 0x846ca68bU;
    x ^= x >> 16;
    return x;
}

float random() {
    seed = hash(seed);
    return float(seed) / 4294967296.0;
}

vec3 randomInUnitSphere() {
    float theta = random() * 2.0 * 3.14159265;
    float phi = acos(2.0 * random() - 1.0);
    float r = pow(random(), 1.0/3.0);
    return r * vec3(sin(phi) * cos(theta), sin(phi) * sin(theta), cos(phi));
}

// Ray structure
struct Ray {
    vec3 origin;
    vec3 direction;
};

// Hit record
struct HitRecord {
    bool hit;
    float t;
    vec3 point;
    vec3 normal;
    uint materialId;
};

// AABB intersection
bool intersectAABB(Ray ray, vec3 boundsMin, vec3 boundsMax) {
    vec3 invDir = 1.0 / ray.direction;
    vec3 t0 = (boundsMin - ray.origin) * invDir;
    vec3 t1 = (boundsMax - ray.origin) * invDir;
    vec3 tmin = min(t0, t1);
    vec3 tmax = max(t0, t1);
    float tenter = max(max(tmin.x, tmin.y), tmin.z);
    float texit = min(min(tmax.x, tmax.y), tmax.z);
    return tenter <= texit && texit > 0.001;
}

// Ray-Triangle intersection (Möller–Trumbore)
bool intersectTriangle(Ray ray, vec3 v0, vec3 v1, vec3 v2, out float t, out vec3 normal) {
    vec3 e1 = v1 - v0;
    vec3 e2 = v2 - v0;
    vec3 p = cross(ray.direction, e2);
    float det = dot(e1, p);
    
    if (abs(det) < 1e-6) return false;
    
    float invDet = 1.0 / det;
    vec3 s = ray.origin - v0;
    float u = dot(s, p) * invDet;
    if (u < 0.0 || u > 1.0) return false;
    
    vec3 q = cross(s, e1);
    float v = dot(ray.direction, q) * invDet;
    if (v < 0.0 || u + v > 1.0) return false;
    
    t = dot(e2, q) * invDet;
    if (t < 0.001) return false;
    
    normal = normalize(cross(e1, e2));
    if (dot(normal, ray.direction) > 0.0) {
        normal = -normal;  // Flip if back-facing
    }
    
    return true;
}

// BVH traversal
HitRecord intersectBVH(Ray ray) {
    HitRecord closest;
    closest.hit = false;
    closest.t = 1e30;
    
    // Stack for traversal (no recursion on GPU)
    int stack[64];
    int stackPtr = 0;
    stack[stackPtr++] = 0;  // Start with root
    
    while (stackPtr > 0) {
        int nodeIdx = stack[--stackPtr];
        BVHNode node = nodes[nodeIdx];
        
        // Test AABB
        if (!intersectAABB(ray, node.boundsMin, node.boundsMax)) {
            continue;
        }
        
        if (node.triCount > 0) {
            // Leaf node - test triangles
            for (uint i = 0; i < node.triCount; i++) {
                GpuTriangle tri = triangles[node.leftFirst + i];
                vec3 v0 = vertices[tri.v0].position;
                vec3 v1 = vertices[tri.v1].position;
                vec3 v2 = vertices[tri.v2].position;
                
                float t;
                vec3 normal;
                if (intersectTriangle(ray, v0, v1, v2, t, normal) && t < closest.t) {
                    closest.hit = true;
                    closest.t = t;
                    closest.point = ray.origin + t * ray.direction;
                    closest.normal = normal;
                    closest.materialId = tri.materialId;
                }
            }
        } else {
            // Internal node - push children
            if (stackPtr < 62) {  // Leave room for 2 children
                stack[stackPtr++] = int(node.leftFirst);
                stack[stackPtr++] = int(node.leftFirst) + 1;
            }
        }
    }
    
    return closest;
}

// Sky color
vec3 skyColor(vec3 direction) {
    float t = 0.5 * (2*direction.z + 2.0);
    return (1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0);
}

// Path tracing with materials
vec3 trace(Ray ray) {
    vec3 color = vec3(1.0);
    vec3 emitted = vec3(0.0);
    
    for (int bounce = 0; bounce < maxBounces; bounce++) {
        HitRecord hit = intersectBVH(ray);
        
        if (hit.hit) {
            // Get material
            GpuMaterial mat = materials[hit.materialId];
            
            // Add emissive contribution
            if (mat.emissiveStrength > 0.0) {
                emitted += color * mat.emissive * mat.emissiveStrength;
            }
            
            // Calculate next ray direction based on material
            vec3 scatter;
            if (mat.metallic > 0.5) {
                // Metallic - reflection
                vec3 reflected = reflect(ray.direction, hit.normal);
                scatter = normalize(reflected + mat.roughness * randomInUnitSphere());
            } else {
                // Dielectric - diffuse
                scatter = normalize(hit.normal + randomInUnitSphere());
            }
            
            // Ensure valid direction
            if (dot(scatter, hit.normal) <= 0.0) {
                scatter = hit.normal;
            }
            
            // Update ray
            ray.origin = hit.point + hit.normal * 0.001;
            ray.direction = scatter;
            
            // Accumulate color with albedo
            color *= mat.albedo * mat.ao;
            
            // Russian roulette for path termination
            float p = max(color.r, max(color.g, color.b));
            if (random() > p) {
                break;
            }
            color /= p;
            
        } else {
            // Hit sky
            emitted += color * skyColor(ray.direction);
            break;
        }
    }
    
    return emitted;
}

void main() {
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    
    // Check bounds
    if (pixelCoords.x >= int(iResolution.x) || pixelCoords.y >= int(iResolution.y)) {
        return;
    }
    
    // Initialize random seed
    seed = hash(uint(pixelCoords.x) + uint(pixelCoords.y) * uint(iResolution.x) + uint(iFrame) * 719393u);
    
    // Generate ray from camera
    vec2 uv = (vec2(pixelCoords) + vec2(random(), random())) / iResolution.xy;
    uv = uv * 2.0 - 1.0;
    
    float aspect = iResolution.x / iResolution.y;
    float fovRadians = radians(cameraFov);
    float halfHeight = tan(fovRadians * 0.5);
    float halfWidth = aspect * halfHeight;
    
    vec3 rayDir = normalize(
        cameraFront + 
        uv.x * halfWidth * cameraRight + 
        uv.y * halfHeight * cameraUp
    );
    
    Ray ray;
    ray.origin = cameraPosition;
    ray.direction = rayDir;
    
    // Trace rays
    vec3 color = vec3(0.0);
    for (int i = 0; i < samplesPerPixel; i++) {
        color += trace(ray);
    }
    color /= float(samplesPerPixel);
    
    // Gamma correction
    color = pow(color, vec3(1.0 / 2.2));  // Gamma correction
    color = clamp(color, 0.0, 1.0);
    
    // Write to output texture
    imageStore(outputImage, pixelCoords, vec4(color, 1.0));
}
