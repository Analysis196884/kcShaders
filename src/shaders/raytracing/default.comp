#version 430 core

layout(local_size_x = 16, local_size_y = 16) in;
layout(rgba32f, binding = 0) uniform image2D outputImage;

// Uniforms
uniform vec3 iResolution;
uniform float iTime;
uniform int iFrame;
uniform int maxBounces;
uniform int samplesPerPixel;

// Camera uniforms
uniform vec3 cameraPosition;
uniform vec3 cameraFront;
uniform vec3 cameraUp;
uniform vec3 cameraRight;
uniform float cameraFov;

// Scene data structures (std430 layout)
struct GpuVertex {
    vec3 position;
    float _pad0;
    vec3 normal;
    float _pad1;
    vec2 uv;
    vec2 _pad2;
};

struct GpuTriangle {
    uint v0, v1, v2;
    uint materialId;
};

struct BVHNode {
    vec3 boundsMin;
    uint leftFirst;
    vec3 boundsMax;
    uint triCount;
};

// SSBOs
layout(std430, binding = 1) buffer Vertices {
    GpuVertex vertices[];
};

layout(std430, binding = 2) buffer Triangles {
    GpuTriangle triangles[];
};

layout(std430, binding = 3) buffer BVHNodes {
    BVHNode nodes[];
};

// Random number generator
uint seed;

uint hash(uint x) {
    x ^= x >> 16;
    x *= 0x7feb352dU;
    x ^= x >> 15;
    x *= 0x846ca68bU;
    x ^= x >> 16;
    return x;
}

float random() {
    seed = hash(seed);
    return float(seed) / 4294967296.0;
}

vec3 randomInUnitSphere() {
    float theta = random() * 2.0 * 3.14159265;
    float phi = acos(2.0 * random() - 1.0);
    float r = pow(random(), 1.0/3.0);
    return r * vec3(sin(phi) * cos(theta), sin(phi) * sin(theta), cos(phi));
}

// Ray structure
struct Ray {
    vec3 origin;
    vec3 direction;
};

// Hit record
struct HitRecord {
    bool hit;
    float t;
    vec3 point;
    vec3 normal;
    vec3 albedo;
};

// AABB intersection
bool intersectAABB(Ray ray, vec3 boundsMin, vec3 boundsMax) {
    vec3 invDir = 1.0 / ray.direction;
    vec3 t0 = (boundsMin - ray.origin) * invDir;
    vec3 t1 = (boundsMax - ray.origin) * invDir;
    vec3 tmin = min(t0, t1);
    vec3 tmax = max(t0, t1);
    float tenter = max(max(tmin.x, tmin.y), tmin.z);
    float texit = min(min(tmax.x, tmax.y), tmax.z);
    return tenter <= texit && texit > 0.001;
}

// Ray-Triangle intersection (Möller–Trumbore)
bool intersectTriangle(Ray ray, vec3 v0, vec3 v1, vec3 v2, out float t, out vec3 normal) {
    vec3 e1 = v1 - v0;
    vec3 e2 = v2 - v0;
    vec3 p = cross(ray.direction, e2);
    float det = dot(e1, p);
    
    if (abs(det) < 1e-6) return false;
    
    float invDet = 1.0 / det;
    vec3 s = ray.origin - v0;
    float u = dot(s, p) * invDet;
    if (u < 0.0 || u > 1.0) return false;
    
    vec3 q = cross(s, e1);
    float v = dot(ray.direction, q) * invDet;
    if (v < 0.0 || u + v > 1.0) return false;
    
    t = dot(e2, q) * invDet;
    if (t < 0.001) return false;
    
    normal = normalize(cross(e1, e2));
    if (dot(normal, ray.direction) > 0.0) {
        normal = -normal;  // Flip if back-facing
    }
    
    return true;
}

// BVH traversal
HitRecord intersectBVH(Ray ray) {
    HitRecord closest;
    closest.hit = false;
    closest.t = 1e30;
    
    // Stack for traversal (no recursion on GPU)
    int stack[64];
    int stackPtr = 0;
    stack[stackPtr++] = 0;  // Start with root
    
    while (stackPtr > 0) {
        int nodeIdx = stack[--stackPtr];
        BVHNode node = nodes[nodeIdx];
        
        // Test AABB
        if (!intersectAABB(ray, node.boundsMin, node.boundsMax)) {
            continue;
        }
        
        if (node.triCount > 0) {
            // Leaf node - test triangles
            for (uint i = 0; i < node.triCount; i++) {
                GpuTriangle tri = triangles[node.leftFirst + i];
                vec3 v0 = vertices[tri.v0].position;
                vec3 v1 = vertices[tri.v1].position;
                vec3 v2 = vertices[tri.v2].position;
                
                float t;
                vec3 normal;
                if (intersectTriangle(ray, v0, v1, v2, t, normal) && t < closest.t) {
                    closest.hit = true;
                    closest.t = t;
                    closest.point = ray.origin + t * ray.direction;
                    closest.normal = normal;
                    closest.albedo = vec3(0.8, 0.8, 0.8);  // Default albedo
                }
            }
        } else {
            // Internal node - push children
            if (stackPtr < 62) {  // Leave room for 2 children
                stack[stackPtr++] = int(node.leftFirst);
                stack[stackPtr++] = int(node.leftFirst) + 1;
            }
        }
    }
    
    return closest;
}

// Sky color
vec3 skyColor(vec3 direction) {
    float t = 0.5 * (direction.y + 1.0);
    return mix(vec3(1.0, 1.0, 1.0), vec3(0.5, 0.7, 1.0), t) * 1.2;
}

// Path tracing
vec3 trace(Ray ray) {
    vec3 color = vec3(1.0);
    
    for (int bounce = 0; bounce < maxBounces; bounce++) {
        HitRecord hit = intersectBVH(ray);
        
        if (hit.hit) {
            // Lambertian diffuse
            vec3 target = hit.point + hit.normal + randomInUnitSphere();
            ray.origin = hit.point;
            ray.direction = normalize(target - hit.point);
            color *= hit.albedo;
        } else {
            // Hit sky
            color *= skyColor(ray.direction);
            break;
        }
    }
    
    return color;
}

void main() {
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    
    // Check bounds
    if (pixelCoords.x >= int(iResolution.x) || pixelCoords.y >= int(iResolution.y)) {
        return;
    }
    
    // Initialize random seed
    seed = hash(uint(pixelCoords.x) + uint(pixelCoords.y) * uint(iResolution.x) + uint(iFrame) * 719393u);
    
    // Generate ray from camera
    // Convert pixel coordinates to NDC space [-1, 1]
    vec2 uv = (vec2(pixelCoords) + vec2(random(), random())) / iResolution.xy;
    uv = uv * 2.0 - 1.0;  // Map from [0,1] to [-1,1]
    
    // Calculate aspect ratio
    float aspect = iResolution.x / iResolution.y;
    
    // Calculate FOV scale
    float fovRadians = radians(cameraFov);
    float halfHeight = tan(fovRadians * 0.5);
    float halfWidth = aspect * halfHeight;
    
    // Calculate ray direction in camera space
    // uv.x is horizontal [-1, 1], uv.y is vertical [-1, 1]
    vec3 rayDir = normalize(
        cameraFront + 
        uv.x * halfWidth * cameraRight + 
        uv.y * halfHeight * cameraUp
    );
    
    Ray ray;
    ray.origin = cameraPosition;
    ray.direction = rayDir;
    
    // Trace rays (multi-sampling)
    vec3 color = vec3(0.0);
    for (int i = 0; i < samplesPerPixel; i++) {
        color += trace(ray);
    }
    color /= float(samplesPerPixel);
    
    // Gamma correction
    color = pow(clamp(color, 0.0, 1.0), vec3(1.0 / 2.2));
    
    // Write to output texture
    imageStore(outputImage, pixelCoords, vec4(color, 1.0));
}
